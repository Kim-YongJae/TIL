# 데이터 모델과 성능
## 정규화
데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법. 데이터를 분해하는 과정.()

제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.
### 정규화 절차
1. 제1정규화
    - 속성의 원자성을 확보
    - 기본키 설정
2. 제2정규화
    - 기본키가 2개 이상의 속성으로 이루어진 경우, **부분 함수 종속성**을 제거(분해)한다.
3. 제3정규화
    - 기본키를 제외한 칼럼 간에 종속성을 제거한다
    - 즉, **이행 함수 종속성**을 제거한다.
4. BCNF
    - 기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해한다.
5. 제4정규화
    - 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다.
6. 제5정규화
    - 조인에 의해서 종속성이 발생되는 경우 분해한다.

## 함수적 종속성(Functional Dependency)
### 제1정규화
정규화는 함수적 종속성을 근거로 한다. 함수적 종속성이란, 'X->Y이면 Y는 X에 함수적으로 종속된다. X의 값이 변화하면 Y도 변화한다.'

**기본키를 잡는 것이 제1정규화이다.**

### 제2정규화
부분 함수 종속성이란, 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생한다. 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략한다.

**부분 함수 종속성을 제거하는 것이 제2정규화이다.**

### 제3정규화
이행 함수 종속성이란, 기본키를 제외하고 칼럼간에 종속성이 발생하는 것이다. 제3정규화는 제1정규화와 제2정규화를 수행한 다음에 해야 한다.

**이행 함수 종속성을 제거하는 것이 제3정규화이다.**

### BCNF
복수의 후보키가 있고, 후보키들이 복합 속성이어야 하며, 서로 중첩되어야 한다.

기본키가 후보키를 종속하고 있고 후보키가 기본키를 종속하는 경우에 분해가 일어난다. 이런 경우에 테이블을 새로 만들고, 후보키가 기본키가 되고 기본키가 칼럼이 된다. 이러한 작업을 BCNF라 한다.
ex. 기본키(학번, 과목 번호)->교수->기본키(과목 번호)

---

### JOIN / ANSI JOIN

|JOIN|||ANSI JOIN||
|--|--|--|--|--|
|SELECT|사원번호, 부서코드, 부서명, 이름, 전화번호, 주소||SELECT|사원번호, 부서코드, 부서명, 이름, 전화번호, 주소|
|FROM|직원, 부서|->|FROM|직원 INNER JOIN 부서|
|WHERE|직원.부서코드=부서.부서코드;||ON|직원.부서코드=부서.부서코드;|

---

이를 프로그램화 한다면, 중첩된 루프를 사용해야한다.

```python
for(i=0; i<N; i=i+1)
    for(j=0; j<N; j=j+1)
        if(직원_부서코드[i]==부서_부서코드[j]){}
```
이러한 경우에 데이터의 양이 많아지면 비교해야 하는 건수도 증가한다. JOIN이 부하를 일으키는 것이고, 정규화의 문제점이 된다. 반정규화를 하여 하나의 테이블에 저장한다면 JOIN을 통한 성능 저하는 해결될 것이다.

이러한 정규화의 문제점을 해결하기 위해 반정규화가 있는 것이다(반정규화 뿐만 아니라 인덱스와 옵티마이저도 해결방법이다).

그렇다면, 왜 반정규화만 사용하지 않는 것일까?

반정규화는 데이터를 중복시키기 때문에 또 다른 문제점을 발생시킨다. 한 엔터티의 칼럼이 계속 증가하면 JOIN이 줄어들기 때문에 조회속도는 빨라질 것이다. 하지만 칼럼이 너무 많아지게되면 한 개 행의 크기가 블록(데이터베이스 관리 시스템의 입출력 단위)의 크기를 넘어서게되고, 한 개 행을 읽으려면 여러개의 블록을 읽어야한다. 이렇게 되면 디스크 입출력이 증가하기 때문에 성능저하가 발생한다(반정규화의 문제점).


반정규화로 인해 생긴 문제점을 해결하려면 테이블을 분해할 수 밖에 없다. 결국 정규화는 입출력 데이터의 양을 줄여서 성능을 향상시킬 수 있는 것이다. 상황에 맞게 정규화와 반정규화를 사용해야한다.

## 반정규화
데이터 중복을 허용하고 JOIN을 줄이는 데이터베이스 성능 향상 방법

반정규화는 조회(SELECT) 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.

### 반정규화를 사용하는 경우
- 정규화를 사용했을 시 수행 속도가 느려지는 경우
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리해야 하는 경우
- 요약/집계 정보가 자주 요구되는 경우

### 반정규화의 절차
1. 대상 조사 및 검토
    - 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상 조사
2. 다른 방법 검토
    - 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다(클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션)
3. 반정규화 수행
    - 테이블, 속성, 관계 등을 반정규화한다.

---
*클러스터링(Clustering)*
- 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법이다.
- 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.
---

### 반정규화 기법
1. 계산된 칼럼 추가
- 배치 프로그램으로 미리 계산하고 그 결과를 특정 칼럼에 추가한다.
2. 테이블 수직 분할
- 하나의 테이블을 두 개 이상의 테이블로 분할. **칼럼을 분할**하여 새로운 테이블을 만든다.
3. 테이블 수평 분할
- 하나의 테이블에 있는 **값을 기준**으로 테이블을 분할하는 방법

---
*파티션(Partition) 기법*


데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러개의 데이터 파일에 분산되어 저장된다.
- Range Partition: 데이터 값의 범위를 기준으로 파티션
- List Partition: 특정한 값을 지정하여 파티션
- Hash Partition: 해시 함수를 적용하여 파티션
- Composite Partition: 범위와 해시를 복합적으로 사용하여 파티션

*파티션 테이블의 장점*
- 데이터 조회 시에 액세스 범위가 줄어들기 때문에 성능이 향상된다.
- 데이터가 분할되어 있기 때문에 Input/Output의 성능이 향상된다.
- 각 파티션을 독립적으로 백업 및 복구가 가능하다.
---
4. 테이블 병합
- 1:1 관계의 테이블을 하나의 테이블로 병합해서 성능 향상
- 1:N 관계의 테이블을 병합하여 성능 향상. 많은 양의 데이터 중복이 발생한다.
- 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.
---
*Super Type과 Sub Type*
- 엔터티간에 부모와 자식 관계(부모: 고객 엔터티 / 자식: 개인고객, 법인고객)
- 배타적 관계: 고객이 개인고객이거나 법인고객.
- 포괄적 관계: 고객이 개인고객일 수도 있고 법인고객일 수도 있다.

*슈퍼 타입 및 서브 타입 변환 방법*
- OneToOne Type
    - 슈퍼 타입과 서브 타입을 개별 테이블로 도출
    - 테이블 수가 많아서 조인이 많아지고 관리가 어렵다
- Plus Type
    - 슈퍼 타입과 서브 타입 테이블로 도출
    - 조인이 발생하고 관리가 어렵다
- Single Type
    - 슈퍼 타입과 서브 타입을 하나의 테이블로 도출
    - 조인 성능이 좋고 관리가 편하다
    - 입출력 성능이 나쁘다
---

## 분산 데이터베이스
### 데이터베이스의 구조
1. 중앙 집중형 데이터베이스
-  한 대의 물리적 시스템에 데이터베이스 관리 시스템 설치하고 여러 명의 사용자가 데잍베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조

2. 분산 데이터베이스
- 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업 처리를 수행하는 데이터베이스

### 분산 데이터베이스의 투명성
분산 데이터베이스를 이용하는 고객은 시스템이 네트워크로 분산되어 있는지 인식하지 못하면서, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다. 그렇기때문에 투명성을 제공해야한다.

#### 투명성의 종류
- 분할 투명성: 고객은 여러 시스템에 저장되어 있음을 인식할 필요성이 없다.
- 위치 투명성: 데이터의 저장 장소를 명시할 필요가 없고, 어디서든지 동일하게 데이터에 접근할 수 있어야 한다.
- 지역 사상 투명성: 지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장되어 각 지역 시스템 이름과 무관한 이름이 사용 가능하다.
- 중복 투명성: 데이터베이스 객체가 여러 시스템에 중복되어 존재하지만 고객과는 무관하게 데이터의 일관성이 유지된다.
- 장애 투명성: 데이터베이스가 시스템이나 통신망에 문제가 생겨도 데이터의 무결성은 보장된다.
- 병행 투명성: 여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행해도 결과에 이상이 없다.

### 분산 데이터베이스의 설계 방식
1. 상향식 설계 방식

- 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축

2. 하향식 설계 방식

- 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축

```
여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리 시스템으로 연동해야 한다. 이기종 데이터베이스 시스템으로 연동하기 위해서는 데이터 베이스 미들웨어(ODBC, JDBC)를 사용해야 한다.
```

#### 분산 데이터베이스의 장점과 단점
- 장점
    - 신뢰성과 가용성이 높다
    - 병렬 처리를 수행하기 때문에 빠른 응답
    - 용량 확장이 쉽다
- 단점
    - 여러 네트워크로 분리되어 있어서 관리와 통제가 어렵다
    - 보안관리가 어렵다
    - 데이터 무결성 관리가 어렵다
    - 데이터베이스 설계가 복잡하다